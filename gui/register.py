# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'register.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_user_register(QtWidgets.QDialog):
    def setupUi(self, user_register):
        super().__init__()
        user_register.setObjectName("user_register")
        user_register.resize(400, 600)
        user_register.setMinimumSize(QtCore.QSize(400, 600))
        user_register.setMaximumSize(QtCore.QSize(400, 600))
        self.register_Label = QtWidgets.QLabel(user_register)
        self.register_Label.setGeometry(QtCore.QRect(80, 90, 220, 80))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(32)
        font.setBold(False)
        font.setWeight(50)
        self.register_Label.setFont(font)
        self.register_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.register_Label.setObjectName("register_Label")
        self.name_reminder_Label = QtWidgets.QLabel(user_register)
        self.name_reminder_Label.setGeometry(QtCore.QRect(50, 190, 240, 100))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        font.setBold(False)
        font.setWeight(50)
        self.name_reminder_Label.setFont(font)
        self.name_reminder_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.name_reminder_Label.setObjectName("name_reminder_Label")
        self.nameinput_lineEdit = QtWidgets.QLineEdit(user_register)
        self.nameinput_lineEdit.setGeometry(QtCore.QRect(190, 220, 131, 41))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        self.nameinput_lineEdit.setFont(font)
        self.nameinput_lineEdit.setText("")
        self.nameinput_lineEdit.setObjectName("nameinput_lineEdit")
        self.record_reminder_Label = QtWidgets.QLabel(user_register)
        self.record_reminder_Label.setGeometry(QtCore.QRect(50, 290, 290, 160))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        font.setBold(False)
        font.setWeight(50)
        self.record_reminder_Label.setFont(font)
        self.record_reminder_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.record_reminder_Label.setWordWrap(True)
        self.record_reminder_Label.setObjectName("record_reminder_Label")
        self.record_pushButton = QtWidgets.QPushButton(user_register)
        self.record_pushButton.setGeometry(QtCore.QRect(100, 480, 60, 60))
        self.record_pushButton.setObjectName("record_pushButton")
        self.save_pushButton = QtWidgets.QPushButton(user_register)
        self.save_pushButton.setGeometry(QtCore.QRect(190, 480, 60, 60))
        self.save_pushButton.setObjectName("save_pushButton")
        self.back_pushButton = QtWidgets.QPushButton(user_register)
        self.back_pushButton.setGeometry(QtCore.QRect(20, 20, 60, 30))
        font = QtGui.QFont()
        font.setFamily("黑体")
        self.back_pushButton.setFont(font)
        self.back_pushButton.setObjectName("back_pushButton")

        self.retranslateUi(user_register)
        QtCore.QMetaObject.connectSlotsByName(user_register)

    def retranslateUi(self, user_register):
        _translate = QtCore.QCoreApplication.translate
        user_register.setWindowTitle(_translate("user_register", "Voiceprint Recognition"))
        self.register_Label.setText(_translate("user_register", "用户注册"))
        self.name_reminder_Label.setText(_translate("user_register", "请输入姓名："))
        self.record_reminder_Label.setText(_translate("user_register", "点击[录音]按钮后\n"
                                                                       "\n"
                                                                       "清晰读出0,2,3,4,5,6,7,8,9\n"
                                                                       "（1由于口音不同不考虑在内）\n"
                                                                       "录音时间持续10秒\n"
                                                                       "\n"
                                                                       "重复三遍后点击[保存]"))
        self.record_pushButton.setText(_translate("user_register", "录音"))
        self.save_pushButton.setText(_translate("user_register", "保存"))
        self.back_pushButton.setText(_translate("user_register", "返回"))

    # register function
    def save(self):
        """
        judge whether the user inputs the complete information
        method:
        先判断文本是否为空 是则继续 否则返回 弹窗提示
        再检查是否有该文件夹 是则继续 否则返回 弹窗提示
        再检查里面是否有三条录音 是则继续 否则false 弹窗提示
        """
        import os

        name = self.nameinput_lineEdit.text()

        if len(name) == 0 or name.isspace():
            msg = QtWidgets.QMessageBox.information(self, '提示', '文本栏为空！\n请先输入用户名')
            return

        USER_DIR = os.path.join(os.pardir, "voiceprint//SpeakerVerificationLock//Enroll", name)

        if not os.path.exists(USER_DIR):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存\n不存在此文件夹！')
            return

        file1_name = name + '_record1.wav'
        file2_name = name + '_record2.wav'
        file3_name = name + '_record3.wav'

        if os.path.exists(os.path.join(USER_DIR, file1_name)) and \
                os.path.exists(os.path.join(USER_DIR, file2_name)) and \
                os.path.exists(os.path.join(USER_DIR, file3_name)):
            # import matlab.engine
            #
            # eng = matlab.engine.start_matlab()
            # eng.cd(os.path.join(os.pardir, "voiceprint"))
            #
            # eng.Train('./SpeakerVerificationLock/CNC2/*/*.wav','./model/BaseModel.mat',nargout=0)
            # eng.Enroll('./SpeakerVerificationLock/Enroll/*/*.wav', './model/BaseModel.mat', './model/CheckPoint.mat',
            #            nargout=0)
            # eng.quit()
            msg = QtWidgets.QMessageBox.information(self, '提示', '保存成功！')
            return
        elif not os.path.exists(os.path.join(USER_DIR, file1_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存录音！')
            return
        elif not os.path.exists(os.path.join(USER_DIR, file2_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未收集完毕！\n还差2次录音')
            return
        elif not os.path.exists(os.path.join(USER_DIR, file3_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存录音！\n还差1次录音')
            return
        else:
            msg = QtWidgets.QMessageBox.information(self, '提示', '录音已经完成！')
            return

    def record_voice(self):
        """
        先判断是否有这个文件夹 否则弹窗提示
        再确认文件 如果已经满了3次则弹窗提示
        最后录音 录音成功则保存
        """
        import os

        name = self.nameinput_lineEdit.text()
        USER_DIR = os.path.join(os.pardir, "voiceprint//SpeakerVerificationLock//Enroll", name)


        file1_name = name + '_record1.wav'
        file2_name = name + '_record2.wav'
        file3_name = name + '_record3.wav'

        if os.path.exists(os.path.join(USER_DIR, file3_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '此用户已经收集数据完毕！')
            return
        elif os.path.exists(os.path.join(USER_DIR, file2_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '按下OK开始录音!\n0 2 3 4 5 6 7 8 9')
            record_with_pyaudio(os.path.join(USER_DIR,file3_name),10)
            msg = QtWidgets.QMessageBox.information(self, '提示', '录音完成！')
        elif os.path.exists(os.path.join(USER_DIR, file1_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '按下OK开始录音!\n0 2 3 4 5 6 7 8 9')
            record_with_pyaudio(os.path.join(USER_DIR,file2_name),10)
            msg = QtWidgets.QMessageBox.information(self, '提示', '录音完成！')
        else:
            msg = QtWidgets.QMessageBox.information(self, '提示', '按下OK开始录音!\n0 2 3 4 5 6 7 8 9')
            record_with_pyaudio(os.path.join(USER_DIR,file1_name),10)
            msg = QtWidgets.QMessageBox.information(self, '提示', '录音完成！')



    def record_data(self):
        """
        while true:
        count=0
        先判断文本是否为空 是则继续 否则返回
        再record voice 录一次count+1
        满了就break
        """
        import os

        name = self.nameinput_lineEdit.text()

        if len(name) == 0 or name.isspace():
            msg = QtWidgets.QMessageBox.information(self, '提示', '文本栏为空！\n请先输入用户名')
            return

        USER_DIR = os.path.join(os.pardir, "voiceprint//SpeakerVerificationLock//Enroll", name)

        if not os.path.exists(USER_DIR):
            os.makedirs(USER_DIR)

        self.record_voice()


def record_with_pyaudio(filename, record_seconds=10, fs = 16000):
    """filename could be absolute path"""
    import pyaudio
    import wave

    chunk = 1024  # Record in chunks of 1024 samples
    sample_format = pyaudio.paInt16  # 16 bits per sample
    channels = 1

    p = pyaudio.PyAudio()  # Create an interface to PortAudio

    print('Recording')

    stream = p.open(format=sample_format,
                    channels=channels,
                    rate=fs,
                    frames_per_buffer=chunk,
                    input=True)

    frames = []  # Initialize array to store frames

    # Store data in chunks for 3 seconds
    for i in range(0, int(fs / chunk * record_seconds)):
        data = stream.read(chunk)
        frames.append(data)

    # Stop and close the stream
    stream.stop_stream()
    stream.close()
    # Terminate the PortAudio interface
    p.terminate()

    print('Finished recording')

    # Save the recorded data as a WAV file
    wf = wave.open(filename, 'wb')
    wf.setnchannels(channels)
    wf.setsampwidth(p.get_sample_size(sample_format))
    wf.setframerate(fs)
    wf.writeframes(b''.join(frames))
    wf.close()
