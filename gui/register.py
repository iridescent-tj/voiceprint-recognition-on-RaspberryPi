# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'register.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_user_register(QtWidgets.QDialog):
    def setupUi(self, user_register):
        super().__init__()
        user_register.setObjectName("user_register")
        user_register.resize(400, 600)
        user_register.setMinimumSize(QtCore.QSize(400, 600))
        user_register.setMaximumSize(QtCore.QSize(400, 600))
        self.register_Label = QtWidgets.QLabel(user_register)
        self.register_Label.setGeometry(QtCore.QRect(80, 90, 220, 80))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(32)
        font.setBold(False)
        font.setWeight(50)
        self.register_Label.setFont(font)
        self.register_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.register_Label.setObjectName("register_Label")
        self.name_reminder_Label = QtWidgets.QLabel(user_register)
        self.name_reminder_Label.setGeometry(QtCore.QRect(60, 200, 221, 81))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        font.setBold(False)
        font.setWeight(50)
        self.name_reminder_Label.setFont(font)
        self.name_reminder_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.name_reminder_Label.setObjectName("name_reminder_Label")
        self.nameinput_lineEdit = QtWidgets.QLineEdit(user_register)
        self.nameinput_lineEdit.setGeometry(QtCore.QRect(190, 220, 131, 41))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        self.nameinput_lineEdit.setFont(font)
        self.nameinput_lineEdit.setText("")
        self.nameinput_lineEdit.setObjectName("nameinput_lineEdit")
        self.record_reminder_Label = QtWidgets.QLabel(user_register)
        self.record_reminder_Label.setGeometry(QtCore.QRect(50, 300, 271, 141))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        font.setBold(False)
        font.setWeight(50)
        self.record_reminder_Label.setFont(font)
        self.record_reminder_Label.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.record_reminder_Label.setWordWrap(True)
        self.record_reminder_Label.setObjectName("record_reminder_Label")
        self.record_pushButton = QtWidgets.QPushButton(user_register)
        self.record_pushButton.setGeometry(QtCore.QRect(100, 480, 60, 60))
        self.record_pushButton.setObjectName("record_pushButton")
        self.save_pushButton = QtWidgets.QPushButton(user_register)
        self.save_pushButton.setGeometry(QtCore.QRect(190, 480, 60, 60))
        self.save_pushButton.setObjectName("save_pushButton")
        self.back_pushButton = QtWidgets.QPushButton(user_register)
        self.back_pushButton.setGeometry(QtCore.QRect(20, 20, 60, 30))
        font = QtGui.QFont()
        font.setFamily("黑体")
        self.back_pushButton.setFont(font)
        self.back_pushButton.setObjectName("back_pushButton")

        self.retranslateUi(user_register)
        QtCore.QMetaObject.connectSlotsByName(user_register)

    def retranslateUi(self, user_register):
        _translate = QtCore.QCoreApplication.translate
        user_register.setWindowTitle(_translate("user_register", "Voiceprint Recognition"))
        self.register_Label.setText(_translate("user_register", "用户注册"))
        self.name_reminder_Label.setText(_translate("user_register", "请输入姓名："))
        self.record_reminder_Label.setText(_translate("user_register", "点击[录音]按钮后\n"
                                                                       "\n"
                                                                       "清晰读出0,2,3,4,5,6,7,8,9\n"
                                                                       "（1由于口音不同不考虑在内）\n"
                                                                       "\n"
                                                                       "重复三遍后点击[保存]"))
        self.record_pushButton.setText(_translate("user_register", "录音"))
        self.save_pushButton.setText(_translate("user_register", "保存"))
        self.back_pushButton.setText(_translate("user_register", "返回"))

    # register function
    def save(self):
        """
        先判断文本是否为空 是则继续 否则返回 弹窗提示
        再检查是否有该文件夹 是则继续 否则返回 弹窗提示
        再检查里面是否有三条录音 是则继续 否则false 弹窗提示
        """
        import os
        CURPATH = os.getcwd()
        USER_DATA = 'user_data'

        name = self.nameinput_lineEdit.text()

        if len(name) == 0 or name.isspace():
            msg = QtWidgets.QMessageBox.information(self, '提示', '文本栏为空！\n请先输入用户名')
            return

        DATA_PATH = os.path.join(CURPATH, USER_DATA, name)

        if not os.path.exists(DATA_PATH):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存\n不存在此文件夹！')
            return

        file1_name = name + '_record1.mp3'
        file2_name = name + '_record2.mp3'
        file3_name = name + '_record3.mp3'

        if os.path.exists(os.path.join(DATA_PATH, file1_name)) and \
                os.path.exists(os.path.join(DATA_PATH, file2_name)) and \
                os.path.exists(os.path.join(DATA_PATH, file3_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '保存成功！')
            return
        elif not os.path.exists(os.path.join(DATA_PATH, file1_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存录音！')
            return
        elif not os.path.exists(os.path.join(DATA_PATH, file2_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未收集完毕！\n还差2次录音')
            return
        elif not os.path.exists(os.path.join(DATA_PATH, file3_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '尚未保存录音！\n还差1次录音')
            return

    def record_voice(self):
        """
        先判断是否有这个文件夹 否则弹窗提示
        再确认文件 如果已经满了3次则弹窗提示
        最后录音 录音成功则保存
        """
        import os
        CURPATH = os.getcwd()
        USER_DATA = 'user_data'

        name = self.nameinput_lineEdit.text()
        DATA_PATH = os.path.join(CURPATH, USER_DATA, name)

        if not os.path.exists(DATA_PATH):
            msg = QtWidgets.QMessageBox.information(self, '提示', '不存在此文件夹！')
            return

        file1_name = name + '_record1.mp3'
        file2_name = name + '_record2.mp3'
        file3_name = name + '_record3.mp3'

        if os.path.exists(os.path.join(DATA_PATH, file3_name)):
            msg = QtWidgets.QMessageBox.information(self, '提示', '此用户已经收集数据完毕！')
            return
        elif os.path.exists(os.path.join(DATA_PATH, file2_name)):
            file3 = open(os.path.join(DATA_PATH, file3_name), 'w')
            file3.write('xxx')
            file3.close()
        elif os.path.exists(os.path.join(DATA_PATH, file1_name)):
            file2 = open(os.path.join(DATA_PATH, file2_name), 'w')
            file2.write('yyy')
            file2.close()
        else:
            file1 = open(os.path.join(DATA_PATH, file1_name), 'w')
            file1.write('dfe')
            file1.close()

        # ps 录音用pyaudio

    def record_data(self):
        """
        while true:
        count=0
        先判断文本是否为空 是则继续 否则返回
        再record voice 录一次count+1
        满了就break
        """
        import os
        CURPATH = os.getcwd()
        USER_DATA = 'user_data'

        if not os.path.exists(os.path.join(CURPATH, USER_DATA)):
            os.makedirs(os.path.join(CURPATH, USER_DATA))

        name = self.nameinput_lineEdit.text()

        if len(name) == 0 or name.isspace():
            msg = QtWidgets.QMessageBox.information(self, '提示', '文本栏为空！\n请先输入用户名')
            return

        DATA_PATH = os.path.join(CURPATH, USER_DATA, name)

        if not os.path.exists(os.path.join(DATA_PATH)):
            os.makedirs(DATA_PATH)
            filename = name + '.txt'
            name_file = open(os.path.join(DATA_PATH, filename), 'w')
            name_file.write(name)
            name_file.close()

        self.record_voice()
